proc calcNetSize_Slicing() {local i, targetCircuit_length, gid, startgid, endgid
					// Calculate the final network size (after any circuit slicing)
					//  The total number of cells 'ncell' is reduced to include only those neurons
					//    - targetCircuit_length: x-length of the target circuit to simulate
					//    - $1: SliceThickness: Thickness of the horizontal slice in microns (x-direction)
					//    - $2: Slices: number of slices along the x-direction
					//    - gid: index of the cell in the original whole network

	// Calculate the number of cells for each cell type, after any slicing
	objref GidsVector = new Vector
	targetCircuit_length = $1*$2		// x-length of the target circuit to simulate
	if (targetCircuit_length < LongitudinalLength) {targetCircuit_length = LongitudinalLength}
	// Actually, skip all this procedure code

	for i=0, numCellTypes-1 {			// For each cell type

		cell_counter = 0
		StartGid = cellType[i].cellStartGid
		EndGid = cellType[i].cellEndGid
		for (gid=StartGid; gid <=EndGid ; gid += 1) {

			xpos=get_x_pos(gid,cellType[i].cellStartGid,cellType[i].dentateXBins,cellType[i].dentateYBins*cellType[i].dentateZBins,cellType[i].dentateXBinSize)
			if (xpos > targetCircuit_length) {

				cellType[i].numCells -= 1
				if (cellType[cellind].numCells == 0) {
					cellType[cellind].numCells = 1
				}	// If all cells of one type
					//  are killed, let 1 live
			}
			else {GidsVector.append(gid)}	// Keep the orginal gid value of that cell in the whole network,
											// for posterior positioning in the target circuit slices
		}

		objref PosGidList = new Vector(numCells)	// After slicing, collects original cell Gids for this celltype,
													// the length of which equals the number of
													// cells left of this type in the model
		cellType[i].PosGidList.copy(GidsVector)
	}

}
calcNetSize_Slicing(SliceThickness, Slices)
